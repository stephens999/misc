---
title: "fastica_centered"
author: "Matthew Stephens"
date: "2025-11-14"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

I found [previously](fastica_02.html) that the original fastICA algorithm seems to have trouble finding groups that are unbalanced. I believe that this is because the log-cosh objective function favours symmetry. ie maximizing or minimizing $\log \cosh (X'w)$ (subject to $w'w=1$, which implies ||X'w||= 1 if $XX'=I$) tends to find symmetric $X'w$.
I want to try to fix this using an intercept. That is,
maximize $\log \cosh (X'w + c)$ over both $w$ and $c$. 

I gave Gemini this problem and it gave me the following 
response and code.

"This adds a new parameter, $c$, that we also need to optimize. We can derive the update rules by taking the partial derivatives of the objective function (negentropy approximation) with respect to both $w$ and $c$ and setting them to zero (this is the Karush-Kuhn-Tucker or KKT-based approach).

This gives us two conditions to satisfy:

For $w$: $E[X g(w^TX + c)] - \lambda w = 0$

For $c$: $E[g(w^TX + c)] = 0$

Where $g$ is your contrast function ($\tanh$) and $\lambda$ is a scalar (Lagrange multiplier).

Condition (2) is new and very intuitive: it means the algorithm must find an intercept $c$ that "centers" the transformed projection $g(P)$ to have a mean of zero. This leads to a simple two-step update within each iteration:

Update c: First, for a fixed w, find the c that solves $E[g(w^TX + c)] = 0$.

Update w: Then, using that new c, perform the standard FastICA update for w."

EDIT1: I found that we also need to constrain c so that
 -max(w'X)< c < -min(w'X) to avoid c going to infinity, so I added this check to the code as a first try.

EDIT2: I found sometimes we converged to suboptimal c, so I added a quick and dirty estimate of c based on 3rd moment of w'X. (this idea also came from a chat with Gemini, and comes from taylor series expansion of the objective)

```{r}
#' Single-unit FastICA update with an intercept term 'c'
#'
#' @param X The pre-processed (centered and whitened) data matrix (p x n).
#' @param w The current weight vector (p x 1).
#' @param c The current intercept scalar.
#' @param c_update_steps How many Newton steps to take for 'c' per iteration. 
#'                       1 is usually sufficient.
#' @return A list containing the updated 'w' (unnormalized) and 'c'.

fastica_r1update_wc = function(X, w, c, c_update_steps = 1) {
  
  # 1. Normalize w (as before)
  w = w / sqrt(sum(w^2))
  
  # --- Step 1: Update the intercept 'c' ---
  
  # Get the current projection *without* the intercept
  # P_current is an (n x 1) vector
  P_current = as.vector(t(X) %*% w) 
  
  # Get a rough estimate of the optimal c using the third moment
  skewness_estimate = mean(P_current^3)
  # Calculate c (using sign() and abs() for robustness with negative numbers)
  c_approx = - sign(skewness_estimate) * (abs(skewness_estimate))^(1/3)
  
  # check if this approximation is better than the current value. Note that my current objective is logcosh, and not the squared deviation from normal, so this is really only going to work for 
  if(compute_objective(X, w, c_approx) > compute_objective(X, w, c)){
    c = c_approx
  }
  
  # We want to find 'c' that solves E[g(P_current + c)] = 0
  # We use one (or more) Newton steps: c_new = c - f(c) / f'(c)
  for (i in 1:c_update_steps) {
    P_shifted = P_current + c
    
    
    # g(P_current + c)
    G_c = tanh(P_shifted) 
    
    # g'(P_current + c)
    G2_c = 1 - tanh(P_shifted)^2 
    
    # E[g(P_current + c)]
    mean_G = mean(G_c) 
    
    # E[g'(P_current + c)]
    mean_G2 = mean(G2_c) 
    
    # The Newton step (add epsilon for stability)
    c = c - mean_G / (mean_G2 + 1e-6)
    
    # impose -max(w'X)< c < -min(w'X)
    P_min = min(P_current)
    P_max = max(P_current)
    if(c <= -P_max){
      c = -P_max + 1e-6
    }
    if(c >= -P_min){
      c = -P_min - 1e-6
    }
  }
  
  # --- Step 2: Update the weight vector 'w' ---
  
  # Now we use the *updated* 'c' to update 'w'
  # P = w'X + c (using the new 'c' from Step 1)
  P = P_current + c 
  
  # g(P)
  G = tanh(P)
  
  # g'(P)
  G2 = 1 - tanh(P)^2
  
  # The FastICA update rule for 'w':
  # w_new = E[X * g(P)] - E[g'(P)] * w
  # (Note: We use sum(G2) as an estimate for E[g'(P)] * n)
  # (and X %*% G as an estimate for E[X*g(P)] * n)
  # The 'n' scaling factor cancels, as 'w' is normalized next iteration.
  w_new = X %*% G - sum(G2) * w 
  
  # 4. Return the updated vector and intercept
  return(list(w = w_new, c = c))
}

#'
#' This is the function that the "profiled" and "skew" update rules
#' are trying to find an extremum (max/min) of.
#'
#' @param X The pre-processed (centered and whitened) data matrix (p x n).
#' @param w The weight vector (p x 1).
#' @param c The intercept scalar.
#' @return The scalar value of the objective function.

compute_objective = function(X, w, c) {
  
  # 1. Normalize w to stay on the ||w||=1 constraint
  w = w / sqrt(sum(w^2))
  
  # 2. Calculate the projection
  P = as.vector(t(X) %*% w) # (n x 1) vector

  # 3. Create the shifted projection
  S = P + c
  
  # 5. Apply G(u) = log(cosh(u))
  G_S = log(cosh(S))
  
  # 6. Compute the expectation (as a sample mean)
  objective_value = mean(G_S)
  
  return(objective_value)
}
```

## Preprocessing code


```{r}
preprocess = function(X, n.comp=10){
  n <- nrow(X)
  p <- ncol(X)
  X <- scale(X, scale = FALSE)
  X <- t(X)
  
  ## This appears to be equivalant to X1 = t(svd(X)$v[,1:n.comp])       
  V <- X %*% t(X)/n
  s <- La.svd(V)
  D <- diag(c(1/sqrt(s$d)))
  K <- D %*% t(s$u)
  K <- matrix(K[1:n.comp, ], n.comp, p)
  X1 <- K %*% X
  return(X1)
}
```



## Simulate data: 3 small groups

Here I simulate 3 groups, with only 20 members each, which I previously found that fastICA had trouble with.
```{r}
K=3
p = 1000
n = 100
set.seed(1)
L = matrix(0,nrow=n,ncol=K)
for(i in 1:K){L[sample(1:n,20),i]=1}
FF = matrix(rnorm(p*K), nrow = p, ncol=K)

X = L %*% t(FF) + rnorm(n*p,0,0.01)
plot(X %*% FF[,1])
```

### centered fastICA (random start)

When I initialize these new updates with a random w, it picks out a single source! (Note: in earlier tries, before the EDITs above, and in particular before the quick-and-dirty estimation of c, this did not happen.)
```{r}
X1 = preprocess(X)
w = rnorm(nrow(X1))
c = 0 # this does not matter as c is updated first
res = list(w=w,c=c)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
res$c
compute_objective(X1,res$w,res$c)
```


### centered fastICA (true factor start)

Now I try initializing at (or close to) a true factor: it converges to the solution I wanted, with a similar objective function as the random start.
```{r}
w = X1 %*% L[,1]
plot(t(X1) %*% w)

c = 0 # note this does not matter much because c gets updated first in the algorithm
res = list(w=w,c=c)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
print(compute_objective(X1,res$w,res$c), digits=20)
```

Try initializing from a different true factor - we see the objective function is almost identical as for the first factor in this case.
```{r}
w = X1 %*% L[,2]
plot(t(X1) %*% w)

c = 0 # note this does not matter much because c gets updated first in the algorithm
res = list(w=w,c=c)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
print(compute_objective(X1,res$w,res$c), digits=20)
```

Same for the third factor: so the objective function for all 3 factors is approximately equal. This is not a coincidence; in general the objective function for all binary factors of equal size should be approximately equal with this centering approach. (There is a question of whether the objective function favors balanced or unbalanced factors, something I need to return to. At first I thought it would always favor unbalanced, but I now believe that this may depend on $n$ because of the constraint $w'w=1$ (rather than $w'w = n$).)
```{r}
w = X1 %*% L[,3]
plot(t(X1) %*% w)

c = 0 # note this does not matter much because c gets updated first in the algorithm
res = list(w=w,c=c)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
print(compute_objective(X1,res$w,res$c),digits=20)
```



### centered fastICA (many random starts)

Here I try with 100 random starts - there are lots of different results, and some of them reach objectives similar to that from the true starts.
```{r}
obj = rep(0,100)
for(seed in 1:100){
  set.seed(seed)
  res = list(w = rnorm(nrow(X1)), c=0)
  for(i in 1:100)
    res = fastica_r1update_wc(X1,res$w,res$c)
  obj[seed] = compute_objective(X1,res$w,res$c)
}
plot(obj)
print(sort(obj,decreasing=TRUE),digits=20)
```

Close inspection of the objective values suggest that first 34 seeds find one factor, seeds 35-67 find another and 68-80 a third.
```{r}
seed= order(obj,decreasing=TRUE)[1]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
max(obj)
```

Here is the seed for the 35th biggest objective 
```{r}
seed= order(obj,decreasing=TRUE)[35]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```

Here is the seed for the 68th biggest objective 
```{r}
seed= order(obj,decreasing=TRUE)[68]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```

### centered fastICA (PC starts)

In initial tries (before introducing checks and quick-dirty approximation for c) most random initializations did not converge well, so I experimented with different initialization strategies.
 
I thought maybe it could be helpful to initialize from the PCs (ie w = (1,0,0..0) etc). There are 10 of these because I'm whitening to 10 dimensions. Before my checks I found initializations using the top PCs do indeed both find a group, and a different group for each one. But now I've added my checks all the PCs provide a good result. Still, initializations using the top PCs might be a strategy worth keeping in mind for the future.
```{r}
obj = rep(0,10)
for(pc in 1:10){
  w = rep(0,10)
  w[pc] = 1
  res = list(w = w, c=0)
  for(i in 1:100)
    res = fastica_r1update_wc(X1,res$w,res$c)
  obj[pc] = compute_objective(X1,res$w,res$c)
}
plot(obj)
print(sort(obj,decreasing=TRUE)[1:10],digits=20)
```

Here I try random starts, but only weighting the top 3 PCs (which should be the ones with the signals). This successfully enriches for finding a good solution and these random starts do find all 3 of the different factors.
```{r}
obj = rep(0,100)
for(seed in 1:100){
  set.seed(seed)
  res = list(w = c(rnorm(3),rep(0,7)), c=0)
  for(i in 1:100)
    res = fastica_r1update_wc(X1,res$w,res$c)
  obj[seed] = compute_objective(X1,res$w,res$c)
}
plot(obj)
```


## 9 groups

Now I try 9 groups, with 20 members each, which should be harder. 
```{r}
K=9
p = 1000
n = 100
set.seed(1)
L = matrix(0,nrow=n,ncol=K)
for(i in 1:K){L[sample(1:n,20),i]=1}
FF = matrix(rnorm(p*K), nrow = p, ncol=K)

X = L %*% t(FF) + rnorm(n*p,0,0.01)
plot(X %*% FF[,1])
```

### centered fastICA (random start)

Again, now that I have added checks on c, initialization to a random w picks out a single source.
```{r}
X1 = preprocess(X)
w = rnorm(nrow(X1))
c = 0 # this does not matter as c is updated first
res = list(w=w,c=c)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
res$c
compute_objective(X1,res$w,res$c)
```


### centered fastICA (true factor start)

Now I try initializing at (or close to) a true factor: again it converges to the solution I wanted, and  has a much higher objective than then random start. 
```{r}
w = X1 %*% L[,1]
plot(t(X1) %*% w)

c = 0 # note this does not matter much because c gets updated first in the algorithm
res = list(w=w,c=c)

for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
print(compute_objective(X1,res$w,res$c), digits=20)
```



### centered fastICA (many random starts)

Here I try with 100 random starts - almost all of them reach objectives similar to that from the true starts. And we can see there seem to be 9 different solutions corresponding to the 9 groups.
```{r}
obj = rep(0,100)
for(seed in 1:100){
  set.seed(seed)
  res = list(w = rnorm(nrow(X1)), c=0)
  for(i in 1:100)
    res = fastica_r1update_wc(X1,res$w,res$c)
  obj[seed] = compute_objective(X1,res$w,res$c)
}
plot(obj)
plot(sort(obj[obj>0.46]))
```

This is the top seed - finds group 1
```{r}
seed= order(obj,decreasing=TRUE)[1]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
max(obj)
```

Here is the seed for the 20th biggest objective (finds the 4th factor)
```{r}
seed= order(obj,decreasing=TRUE)[20]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```


### Try finding two groups

It turns out that factors 3 and 9 are not overlapping in this simulation, so I wondered whether combining them would
be a good solution. Initializing at that combination does find the combined solution, but the objective is lower than for a single group because the objective favors unbalanced groups.
```{r}
# show 3 and 9 are not overlapping
L[,3]*L[,9]
w = X1 %*% (L[,3] + L[,9])
plot(t(X1) %*% w)

c = 0 # note this does not matter much because c gets updated first in the algorithm
res = list(w=w,c=c)
print(compute_objective(X1,res$w,res$c), digits=20)

for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
print(compute_objective(X1,res$w,res$c), digits=20)
```

Interestingly this seems to be an unstable solution: if I initialize nearby then it moves away to a single group. 
```{r}
w = X1 %*% (0.45*L[,3] + 0.55*L[,9])
plot(t(X1) %*% w)

c = 0 # note this does not matter much because c gets updated first in the algorithm
res = list(w=w,c=c)
print(compute_objective(X1,res$w,res$c), digits=20)

for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
print(compute_objective(X1,res$w,res$c), digits=20)
```

## Four non-overlapping groups

Here I look at 4 equal non-overlapping groups. I'm interested in whether it converges to a single group or a combination of groups, and whether the combination of 2 groups is a stable or unstable solution. It turns out that the majority of random starts converge to a combination of 2 groups, which is very different behavior than above. It gets me wondering whether this is because i) the non-overlapping situation, or ii) the symmetry created by the fact there are only 4 groups (2 vs 2). 

```{r}
set.seed(1)
n = 100
p = 1000
L = matrix(0,nrow=n,ncol=4)
L[1:25,1] = 1 
L[26:50,2] = 1 
L[51:75,3]  = 1
L[76:100,4] = 1
FF = matrix(rnorm(p*4),nrow=p) 
X = L %*% t(FF) + rnorm(n*p,0,0.01)
image(X%*% t(X))
X1 = preprocess(X,n.comp=4)
```


### centered fastICA (many random starts)

Here I try with 100 random starts. Some seeds (18) find a big objective (turns out to correspond to a single group) and others find what looks like a very similar objective (turns out to correspond to a combination of two groups).
```{r}
obj = rep(0,100)
for(seed in 1:100){
  set.seed(seed)
  res = list(w = rnorm(nrow(X1)), c=0)
  for(i in 1:100)
    res = fastica_r1update_wc(X1,res$w,res$c)
  obj[seed] = compute_objective(X1,res$w,res$c)
}
plot(obj)
plot(sort(obj[obj>0.48]))
print(sort(obj,decreasing=TRUE)[1:20],digits=20)
```

Here is the seed for the biggest objective (finds factor 1)
```{r}
seed= order(obj,decreasing=TRUE)[1]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```


Here is the seed for the 19th biggest objective (finds two combined factors)
```{r}
seed= order(obj,decreasing=TRUE)[19]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```

## Nine non-overlapping groups

Here I look at 9 equal non-overlapping groups. 

Start by creating L to be a binary matrix with 9 columns, 25*9 rows, and a single 1 in each row.
```{r}
set.seed(1)
n = 225
p = 1000
L = matrix(0,nrow=n,ncol=9)
for(i in 1:9){L[((i-1)*25+1):(i*25),i] = 1}
FF = matrix(rnorm(p*9),nrow=p)
X = L %*% t(FF) + rnorm(n*p,0,0.01)
image(X%*% t(X))
X1 = preprocess(X,n.comp=10)
```


### centered fastICA (many random starts)

Here I try with 100 random starts.
```{r}
obj = rep(0,100)
for(seed in 1:100){
  set.seed(seed)
  res = list(w = rnorm(nrow(X1)), c=0)
  for(i in 1:100)
    res = fastica_r1update_wc(X1,res$w,res$c)
  obj[seed] = compute_objective(X1,res$w,res$c)
}
plot(obj)
```

Results for the top seed: it finds a split that combines groups.
```{r}
seed= order(obj,decreasing=TRUE)[1]
set.seed(seed)
res = list(w = rnorm(nrow(X1)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
res$c
obj[seed]
```

Here I try initializing at a single group. I discovered that the objective is actually lower than for the combined groups - so maybe this explains why it is finding the combined group result! This was a surprise to me. I should try to understand better what is going on here. One possibility is that, because we are imposing w'w = 1, the results may depend on n - as w get's smaller, the behavior of log cosh is different. Maybe we should impose w'w = n?
```{r}
w = X1 %*% L[,1]
plot(t(X1) %*% w)

c = 0 # note this does not matter much because c gets updated first in the algorithm
res = list(w=w,c=c)
print(compute_objective(X1,res$w,res$c), digits=20)

for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
print(compute_objective(X1,res$w,res$c), digits=20)
```





### Tree simulations

Here is a simple tree-based simulations; it's a 4-leaf tree with two bifurcating branches.
```{r}
# set up L to be a tree with 4 tips and 7 branches (including top shared branch)
set.seed(1)
n = 100
p = 1000
L = matrix(0,nrow=n,ncol=6)
L[1:50,1] = 1 #top split L
L[51:100,2] = 1 # top split R
L[1:25,3]  = 1
L[26:50,4] = 1
L[51:75,5] = 1
L[76:100,6] = 1
FF = matrix(rnorm(p*6),nrow=p) 
X = L %*% t(FF) + rnorm(n*p,0,0.01)
image(X%*% t(X))
X1 = preprocess(X)
```


Run 100 seeds, weighting only the top 3 PCs in the initialization (note: when I did the same weighting the top 4 PCs I got more mixed branch solutions). We see that the top seeds pick out a single group. Next seeds are the top branch, but then after that we have a bunch of seeds that combine two groups that are not adjacent on the tree - these solutions are less attractive to us. It would be nice to find a wy to avoid these mixed-branch solutions (or develop a filter to remove them?). One thing I don't quite understand is that the objective for the mixed branch solutions seems to be consistently, but very slightly, lower than for the single-branch solution. That would be good to understand better.
```{r}
obj = rep(0,100)
Lhat = matrix(nrow=100,ncol=n)
for(seed in 1:100){
  set.seed(seed)
  res = list(w = c(rnorm(3),rep(0,7)), c=0)
  for(i in 1:100)
    res = fastica_r1update_wc(X1,res$w,res$c)
  obj[seed] = compute_objective(X1,res$w,res$c)
  Lhat[seed,] = t(X1) %*% res$w
}
plot(obj)
image(Lhat[order(obj,decreasing=TRUE),])
```

The top seed is a single group:
```{r}
seed = order(obj,decreasing=TRUE)[1]
set.seed(seed)
res = list(w = c(rnorm(3),rep(0,7)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)

cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```

Results for the 10th biggest seed:
```{r}
seed = order(obj,decreasing=TRUE)[10]
set.seed(seed)
res = list(w = c(rnorm(3),rep(0,7)), c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)

cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```


## Exploratory stuff (maybe best ignored for now?)

Noting here an idea to investigate: maybe initialize w "orthogonal" to previous ones (but don't impose orthogonality during iterations) to try to find different solutions? Here's what I mean. The problem is that there are 5 solutions we want to find here - not sure how to try to find all of them.
```{r}
set.seed(1)
w.init = c(rnorm(3),rep(0,7))
w.init = w.init - sum(w.init * res$w)/(sum(res$w^2)) * res$w
res = list(w = w.init, c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```


### Initialize in the original space

Here I try initializing by a random linear combination of the columns of the original X. Then I choose w so that X1' w equals this l1.
```{r}
set.seed(1)
w1 = rnorm(ncol(X)) # linear comb of columns in the original space
l1 = X %*% w1
w = X1 %*% l1
w.init = w/mean(w^2)
plot(t(X1) %*% w.init, l1)
```

Initializing here gives the two groups.
```{r}
res = list(w = w.init, c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
lhat = t(X1) %*% res$w
what = t(X) %*% lhat # finds an optimal w in the original space
```

Now find the what in the original space that corresponds to this solution, and initialize orthogonal to what in the original space
```{r}
w1 = rnorm(ncol(X))
w1 = w1 - sum(w1 * what)/(sum(what^2)) * what # orthogonal to what

l1 = X %*% w1
w = X1 %*% l1
w.init = w/mean(w^2)
plot(t(X1) %*% w.init, l1)
```

Running from this one produces a mixed group. And this seems to happen repeatedly with this strategy. Need to investigate this more carefully.
```{r}
res = list(w = w.init, c=0)
for(i in 1:100)
  res = fastica_r1update_wc(X1,res$w,res$c)
cor(L,t(X1) %*% res$w)
plot(as.vector(t(X1) %*% res$w))
```



